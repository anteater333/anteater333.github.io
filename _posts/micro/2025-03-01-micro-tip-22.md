---
layout: post
title: "자잘한 도움말 #22 Next.js에서 서버와 클라이언트의 괴리감 처리하기"
subtitle: "Hydration Mismatch란 무엇인가"
description: ""
date: 2025-03-17 08:40:00 +0900
category: micro

id: 22
slug: hydration-mismatch
tags: [💡, Front-end, Next.js]

coverImage: "/assets/blog/coverImages/micro-22.png"

ogImage:
  url: "/assets/blog/coverImages/micro-22.png"
---

- Hydration Mismatch
    - Next.js 사용 시 문제
    - 대표적으로 new Date()
    - 무시할 수 있는 hydration mismatch new Date
    - 무시할 수 없는 hydration mismatch 테마 (store 초기 설정시 로컬 스토리지에 저장된 테마 가져오는 코드에서 발생한 문제, 83ec7fb67b21fb3ebf32ec49e6c1a60ba66f6b67 커밋 참고) -> 이건 보류
- `suppressHydrationWarning` 한 줄 추가로 해결 가능하다. (하지만 이건 에러를 무시하는 방법?)
- 클라이언트에서만 결과가 나오도록 만든다? (훅을 사용해서)
- 하이드레이션이란?? -> Hack the terms로 가려다가 그냥 여기서 다뤄보면 좋을 것 같음

- 서버에 있는 렌더링된 결과 vs 클라이언트에서 렌더링된 결과가 서로 달라서 생기는 문제

- 왜 문제가 되는가?? (by copilot)  

```plaintext
Hydration mismatch는 서버에서 렌더링된 HTML과 클라이언트에서 React가 초기화될 때 생성된 HTML이 일치하지 않을 때 발생합니다. 이는 여러 가지 문제를 일으킬 수 있습니다:

사용자 경험 문제:

사용자가 페이지를 로드할 때 깜빡임이나 레이아웃이 갑자기 변경되는 현상이 발생할 수 있습니다. 이는 사용자 경험을 저하시킬 수 있습니다.
SEO 문제:

서버에서 렌더링된 HTML이 검색 엔진에 의해 인덱싱되기 때문에, 클라이언트 측에서 다른 HTML이 렌더링되면 검색 엔진이 잘못된 정보를 인덱싱할 수 있습니다.
디버깅 어려움:

Hydration mismatch는 디버깅하기 어려운 문제 중 하나입니다. 서버와 클라이언트의 상태가 다를 때 발생할 수 있는 문제를 추적하고 해결하는 데 많은 시간이 소요될 수 있습니다.
성능 문제:

Hydration mismatch가 발생하면 React는 클라이언트 측에서 전체 DOM을 다시 렌더링해야 할 수 있습니다. 이는 성능 저하를 초래할 수 있습니다.
이를 방지하기 위해 서버와 클라이언트에서 동일한 상태와 데이터를 사용하여 일관된 HTML을 생성하는 것이 중요합니다. 예를 들어, 서버에서 데이터를 가져와 렌더링할 때와 클라이언트에서 동일한 데이터를 사용하여 렌더링할 때 일관성을 유지해야 합니다.

다음은 Hydration mismatch를 방지하기 위한 몇 가지 팁입니다:

동일한 데이터 소스 사용:

서버와 클라이언트 모두 동일한 데이터 소스를 사용하여 렌더링합니다.
조건부 렌더링 최소화:

서버와 클라이언트에서 조건부 렌더링을 최소화하여 일관된 HTML을 생성합니다.
동일한 상태 관리:

서버와 클라이언트에서 동일한 상태 관리 라이브러리를 사용하여 상태를 일관되게 유지합니다.
환경 변수 사용:

서버와 클라이언트에서 동일한 환경 변수를 사용하여 일관된 설정을 유지합니다.
이러한 방법을 통해 Hydration mismatch 문제를 방지하고, 서버와 클라이언트에서 일관된 HTML을 생성할 수 있습니다.
```


https://nextjs.org/docs/messages/react-hydration-error

- A server/client branch `if (typeof window !== 'undefined')`.
- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

- 근데 왜 SSG에서 이런 에러가 떴을까? (빌드 후에도 콘솔에 출력되는 에러 Minified React error #418)



```tsx
import { format } from "date-fns";

type Props = {
  dateString: string;
};

const DateFormatter = ({ dateString }: Props) => {
  // Safari의 parsing 알고리즘이 유독 저열하기 때문에 전처리
  const date = new Date(
    Date.parse(dateString.replace(" ", "T").replace(" ", ""))
  );

  return (
    <time dateTime={dateString} suppressHydrationWarning>
      {format(date, "LLLL	d, yyyy")}
    </time>
  );
};

export default DateFormatter;
```

<strong>[참고자료들]</strong>


- https://ui.toast.com/weekly-pick/ko_20210119

궁금한게있는데
Hydration Mismatch는 서버 컴포넌트 때문인가 SSR 때문인가.

- https://developer-haru.tistory.com/81  
이 글 상당히 좋은데?

- https://blog.hwahae.co.kr/all/tech/13604

## TL;DR

- Hydration이란 ~~
- ~~로 인해 Hydration Mismatch가 발생한다
- Hydration Mismatch를 해결하는 방법
- Hydration Mismatch를 무시하는 방법

## 이하 그리 중요하진 않은 내용들

호기롭게 시작을 세상에 공표했던 개인 프로젝트는 아직까지 지지부진해 첫 삽도 뜨지 못한 가운데, 아무런 새 글도 없이 블로그가 죽은 것 처럼 보이면 신세가 참 처량해 보이겠다 싶어 이번에도 자잘한 도움말을 써보려 시도하고있다. 그런 고로 이번에도 주제는 블로그 리모델링 중 있었던 일이다. 아니 블로그 재개발도 어느덧 벌써 반년 전의 일이 되어버렸는데 언제까지 이걸 울궈먹을런지.

### SSR과 CSR

나는 이 블로그를 React와 Next.js 프레임워크를 사용해 구축했다. 얼마 전 알게된 사실인데 CRA(`create-react-app`)이 deprecated 처리된 이후 React 공식 문서에선 새 React 앱을 만들 땐 Next.js를 사용할 것을 권장하고 있더라고. 아니 왜 Vite 놔두고 그런담.

<p class="center w-3-quarter">
<a href="https://react.dev/learn/creating-a-react-app">
<img src="https://i.postimg.cc/XvsMSwBZ/image.png" alt="nextjs쓰세요"/>
</a>
<br/>
심지어 <a href="https://react.dev/learn/build-a-react-app-from-scratch">프레임워크 없이 구축하는 방법 소개 페이지</a>에 가도 프레임워크 좀 쓰라고 꽤 질척거린다
</p>

물론 이 블로그를 Next.js로 만든 주제에 몽니를 부리고 있지만, 블로그엔 Next.js의 장점이 꼭 필요했기 때문이었다. 그렇담 Next.js의 그 장점이란 무엇일까. Next.js와 같은 프레임워크를 사용하지 않고 리액트 라이브러리와 Vite나 Rollup 같은 번들러로 사이트를 만들면 일반적으로 클라이언트에서 자바스크립트를 실행해 HTML을 생성하는 <strong>CSR(Client Side Rendering)</strong> 방식의 SPA(Single Page Application)로 결과물이 나올 것이다. SPA는 수많은 현대 웹 서비스들의 가능성을 넓혀준 패러다임이지만, 근본적인 문제가 하나 있다. 클라이언트에서 자바스크립트를 실행해 HTML을 생성한다는 것은 다시말해 클라이언트가 그럴 능력을 갖추고 있어야 한다는 것이다. 일반 사용자들이 사용하는 웹 브라우저에겐 그 능력이 기본적으로 내장되어 있지만, 웹 서핑은 웹 브라우저만 하는 것은 아니다.

<a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_%ED%81%AC%EB%A1%A4%EB%9F%AC">웹 크롤러</a>는 자동화된 방법으로 웹을 탐색하는 컴퓨터 프로그램이다. 그러니까 사람이 조작해서 웹 페이지를 탐색하게끔 하는 웹 브라우저와 달리 웹 크롤러란 물건은 자기들이 알아서 웹 페이지들을 기어다니며 목적에 따라 필요한 내용을 읽어야 한다. 그리고 그 목적의 대표적인 사례가 바로 구글과 같은 검색 엔진의 인덱싱이다. 효율성을 위해 크롤러는 그 동작이 웹 브라우저에 비해 가벼울 수 밖에 없다. 무슨 말이냐면, 웹 크롤러는 일반적으로 자바스크립트를 실행할 능력, 다시말해 자바스크립트 엔진이 없다. 따라서 웹 크롤러는 일반적으로 CSR을 수행하지 못한다. 자바스크립트를 해석하지 못하는 웹 크롤러가 SPA 사이트에 접속하면 검색 엔진에 등록할 만한 정보가 하나도 들어 있지 않은 빈 화면으로 사이트를 인식할 것이다. 그래서 SPA 방식으로 만든 웹 서비스는 검색 엔진의 검색 결과에 제대로 노출되기가 어렵다는 치명적인 단점을 가지고 있는 것이다.

글 신나게 썼는데 구글 네이버 다음 등등 검색 서비스들에게 외면당하면 안되잖아. 따라서 블로그 개발에는 웹 크롤러도 인식할 수 있는 형태로 서버가 1차적인 렌더링을 해주는 방식, <strong>SSR(Server Side Rendering)</strong>을 지원하는 프레임워크 Next.js를 사용했다. 정리하자면 이렇게 웹 어플리케이션의 구현을 CSR과 SSR이라는 큰 두 방식의 분류로 나눌 수 있겠다. 근데 사실 엄밀히 따지면 하나를 쓴다고 다른 한 쪽은 완전히 사장되는 것은 아니긴 하다. 워낙 각자의 장단점이 뚜렷하기 때문. 게다가 어떤 사이트를 SSR 방식으로 만들었다고 그 사이트엔 CSR이란 개념이 아에 존재하지 않는 것도 아니다. 그렇기 때문에 두 방식은 서로 얼마나 다르고, 어떻게 융화되는지에 대해서 알아둘 필요가 있다.

### Hydration

조금 억지스럽게 느껴질 수도 있겠지만, 사용자가 완성된 웹 페이지를 이용하는 것을 식사에 비유해보자. 먼저 고전적인 웹 서버는 이미 다 만들어져 바로 먹을 수 있는 완제품을 파는 편의점, WAS는 주문을 받았을 때 주방장이 요리를 시작하는 식당이라고 볼 수 있다.

이 비유를 현대적인 웹 페이지 구현 방식들에도 적용해본다면, CSR과 SSR은 사용자에게 재료와 레시피를 쥐어주고 직접 요리하길 요구하는 방식이라고 말할 수 있겠다. CSR은 사용자가 직접 원재료 손질부터 시작한다는 느낌이라면, SSR은 마치 밀키트를 구입하는 것과 비슷하다. 고기도 이미 양념에 재워져 있고 감자 껍질도 벗겨져있고 물만 붓고 끓이기만 하면 된다. 이것도 어쨌든 요리긴 하지. SSR에서 그 물을 끓이는 행위를 바로 <strong>하이드레이션(Hydration, 수분공급)</strong>이라고 부른다.

CSR에선 두 동작이 결합되어 있었기에 구분이 확실하지 않았지만, 웹 페이지 생성 과정에서 프로그래밍 언어의 동작은 다음 둘로 나눌 수 있다.

1. 렌더링(Rendering) : 화면 구성요소(마크업, HTML)를 생성한다.
2. 하이드레이션(Hydration) : 화면의 동작 코드(스크립트, JS)를 앞서 생성한 마크업과 연결한다

SSR은 위 두 과정 중 렌더링을 서버에서 담당한다. 하지만 클라이언트가 받은 웹 페이지의 최초 소스는 동작이 정의되어있지 않은 매마른 형태일 것이다. 따라서 웹 페이지에 동작을 연결하는 두 번째 과정을 웹 페이지를 촉촉하게 만든다는 의미에서 하이드레이션이라고 부르는 것이다.

<p class="center w-3-quarter rounded-edge-16">
<img src="https://i.postimg.cc/2ymkqBHk/micro-22.png" alt="hydration"/>
<br/>
엔지니어들의 비유력이란.
</p>

기존엔 `hydrate`란 API가 제공되었었고, 리액트 18버전부터는 `hydrateRoot`를 사용한다. 공식 문서에서 설명하길, <strong>서버 환경에서 먼저 리액트로 렌더링 된 HTML에 리액트를 "부착"하려면 `hydrateRoot`를 호출하면 된다.</strong> 여기서 알 수 있는 점은 결국 하이드레이션이란 클라이언트에서 수행해야 하는 작업이란 것이다.

```jsx
// 서버 측
import { renderToString } from 'react-dom/server'

const html = renderToString(<App />); // Server Side Rendering

// (렌더링 결과인 html이 클라이언트에게 전달된다.)

// 클라이언트 측
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = hydrateRoot(domNode, reactNode); // Hydration
```

### Hydration Mismatch

밀키트 조리 예상도와 실제 요리 결과가 다를 때

서버가 생각한 페이지의 상태 vs 실제로 사용자가 받은 상태

그럼 Next.js SSG로 제공한 서비스는 어떻게 그걸 알아차리는거지...?
  - 이 부분에선 가설을 세워보고 제대로 찾아볼것
  - 예를들면, 사용자가 제공받은 최초 페이지는 최초 렌더링이 되어있는 상태로 들어있다던가...

  - 위에서 설명한 방식에 따르면 SSG라고 하이드레이션이 없는게 아니다.
  - SSR은 구 WAS 방식처럼 최초 렌더링 시 서버에서 동적 생성을 하는 것

해결법 설명

서버의 상태와 동일하게 맞추기, `suppressHydrationWarning`

## 내가 배운 것
