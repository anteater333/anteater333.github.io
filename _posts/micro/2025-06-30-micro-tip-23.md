---
layout: post
title: "자잘한 도움말 #23 모바일 웹에서 딥 링크 흘리기"
subtitle: "FE 개발자 입장에서의 딥 링크"
description: ""
date: 2025-06-15 07:12:00 +0900
category: micro

id: 23
slug: parrying-deep-link
tags: [💡, Front-end]

coverImage: "/assets/blog/coverImages/micro-23.png"

ogImage:
  url: "/assets/blog/coverImages/micro-23.png"
---

## TL;DR

https://soop-global.atlassian.net/wiki/spaces/FE1/pages/159613017/m.sooplive.co.kr+-

이거 참고할것

## 이하 그리 중요하진 않은 내용들

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/N07f901w/deeplink.webp" alt="철찌식설명"/>
  <br/>
  오타쿠식 강제연결
</p>

철권의 등장인물 알리사 보스코노비치는 설정상 로봇으로서, 그 컨셉 따라 대부분의 기술명이 IT 용어로 이루어져 있다. 그중 앉으면서 상대방의 다리를 툭 치는 기술 "딥 링크(1LK)". 2008년 첫 등장부터 특유의 상대하기 짜증 나는 성능 덕분에 딥 링크는 알리사의 상징적인 기술 중 하나로 철권 유저들 사이에 악명을 떨치고 있다. 그런데 이 게임뿐만이 아니라 현실 속 딥 링크 또한 프론트엔드 개발자의 짜증을 유발하기도 한다. 딥 링크란 무엇일까? 딥 링크는 어떤 까다로운 동작을 유발할까? 그것을 어떻게 회피해야 할까?


### 모바일 퍼스트

스마트폰은 인간의 새로운 장기가 되어가고 있다. 극단적인 사례로서 <a href="https://www.musinsa.com/">무신사</a>는 한때 PC 웹 서비스를 종료하고 모바일 웹 형태로만 서비스를 제공했던 바가 있다. 비록 10개월 만에 다시 돌아오긴 했으나, 이는 기업들이 생각하는 PC와 모바일 간의 중요도 저울이 한쪽으로 크게 기울고 있단 증거 중 하나일 것이다. 국내 스마트폰 사용자는 한국 전체 인구의 95%에 해당한다고 한다. 그 거대한 스마트폰 사용자의 파이를 먹기 위해 각종 웹 기반 서비스들은 오늘도 적극적으로 사용자에게 더 좋은 모바일 기기 경험을 제공하려고 노력하고 있다.

하지만 아무리 그렇게 폭발적인 수요에 힘입어 모바일 기기가 발전하고 있더라도 그 성능엔 물리적인 한계가 있다. 게다가 네이티브 어플리케이션이 아닌 웹 브라우저 내부에서 실행되는 웹 페이지라면 그 한계는 한 단계 더 심해질 것이다. 일례로, 구매한 지 4년 정도 된 내 갤럭시 S21로 모바일 웹 브라우저에서 트위터나 지메일 같은 사이트를 접속하면 이젠 쓰기 힘들 정도로 버벅댄다. 글자 하나 타이핑하는 데 1초씩 걸리면 누가 그 서비스를 이용하고 싶어 할까. 이런 상황에서 어떻게든 모바일 사용자들을 붙잡기 위해 엔지니어들이 선택한 방법은, 모바일 웹 브라우저를 최대한 피하도록 만드는 것이었다. 네이티브 어플리케이션을 사용한다면 모바일 기기의 성능을 더 끌어올릴 수 있을 테니.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/VLMn6pXs/image.png" alt="딥링크"/>
</p>

딥 링크(Deeplink)란, URI를 통해 어플리케이션 내부의 구체적인 위치를 명시하는 방법을 의미한다. 예를 들어, `https://youtube.com/watch?v=w66Kzs7UIHk` 이런 링크를 모바일 기기로 들어간다고 했을 때, 사용성 나쁘고 성능적 제한도 있는 모바일 웹 브라우저에서 웹 페이지 형태로 보여주는 것이 아니라 해당 링크에 연결된 유튜브 네이티브 어플리케이션의 특정 위치로 이동하도록 만들 수 있다는 것이다. 오늘 글도 그렇고 대부분의 맥락에선 모바일 기기를 사용하는 입장에서 쓰이는 용어이긴 하지만, 원론적으론 "어플리케이션의 내부 위치를 URI와 연결"이라는 개념은 어떤 환경에서도 적용될 수 있다. 예를 들면, PC에서 Notion을 웹 브라우저로 접속했을 때도 어플리케이션으로 열기라는 버튼이 포함된 토스트 UI가 노출되는 것을 볼 수 있다.

### 딥 링크 삼국시대

어떻게 그런 게 가능하냐면 딥 링크란 어떤 특정 플랫폼에 종속되는 기술이 아니라 일종의 제안 같은 것이기 때문이다. 그래서 그 제안을 어떻게 구현할 것인가는 각 플랫폼 개발사에 달려있고, 서비스 개발자들은 그 방식에 맞춰 따라가면 된다.

#### URI Scheme

먼저 소개할 방식은 가장 플랫폼에 덜 종속적인 방식이라고 할 수 있다. 바로 딥 링크만을 위한 URI를 만드는 것. 우선 팀 버너스리가 정의한 URI의 구조는 다음과 같다.

```plaintext
URI = scheme ":" ["//" authority] path ["?" query] ["#" fragment]
```

웹 사이트의 주소를 나타낼 땐 <strong>`scheme`</strong> 부분에 `http` 혹은 `https`가 들어간다. 하이퍼텍스트 기반 통신 프로토콜 HTTP를 사용해 해당 주소로 접속하라는 의미이다. 이처럼 스킴(Scheme)은 그 주소로 접근하기 위해 사용해야 하는 프로토콜이나 방법을 명시하기 위해 사용된다. `http`/`https`, `ftp`, `mailto`, `ssh` 등 <a href="https://ko.wikipedia.org/wiki/IANA">IANA</a>에 <a href="https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml">공식적으로 등록</a>된 스킴을 대부분 사용하는데, 그렇다고 꼭 URI에 등록된 스킴만 사용하라는 법칙은 없다. 등록된 스킴 대신 URI의 스킴 자리에 <strong>앱 스킴(App Scheme)</strong>이라는 것을 명시할 수 있다.

> `youtube://watch?v=w66Kzs7UIHk`

예를 들어 앱 스킴을 사용하면 위와 같이 유튜브 어플리케이션 내부에서 특정 영상을 재생하는 화면을 URI로 표현할 수 있다. 개념적으로는 이렇지만 그렇다고 무턱대고 저 링크를 써먹으려고 한다면 동작하지 않을 것이다. 가령 개발자 도구를 열고 `window.open('youtube://watch?v=w66Kzs7UIHk')` 이렇게 입력한다면 다음과 같은 응답이 출력되는 것을 볼 수 있다.

```javascript
window.open(`youtube://watch?v=w66Kzs7UIHk`);
// Failed to launch 'youtube://watch?v=w66Kzs7UIHk' because the scheme does not have a registered handler.
```

공식적으로 등록되지 않은 스킴이란 말은 사용자의 PC에라도 등록이 되어야 사용할 수 있다는 의미이기 때문이다. 오늘의 주제는, 그리고 FE 엔지니어에게 필요한 정보는 스킴을 사용하는 법이지 등록하는 법은 아니기 때문에 그냥 그렇다고 치고 넘어가도록 하자. 파편적으로 정보만 던져두자면, 각 플랫폼 네이티브 어플리케이션 개발 도구에서 설정법을 알려줄 것이다.

앱 스킴 방법의 장점은 간단하다는 것이다. URI의 그 목적에 맞게 명시적으로 앱 내부의 특정 화면을 사용자와 연결시켜 줄 수 있다. 또 한 가지 장점은 서버에 의존하지 않아도 된다는 점이다. 예를 들어 `youtube://watch?v=w66Kzs7UIHk`라는 링크는 보이듯 그 프로토콜이 HTTP가 아니다. 때문에 링크의 이동은 로컬에서 `youtube`라는 스킴을 실행할 수 있는 어플리케이션을 찾아 실행하는 흐름으로 실행된다. 발견되지 않으면 특정 웹 서버에 요청을 보내는 것이 아니라 그 링크를 실행할 수 없다는 에러를 보내고 끝인 것이다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/VLMn6pXs/image.png" alt="딥링크"/>
</p>

하지만 이건 역으로 단점으로 다가오기도 한다. 이 이미지를 다시 보면서 UX 측면을 생각해 보자. 그렇게 별도의 웹 서버를 타지 않는 방식이라면 위 경로, "앱 미설치 시(App not installed)" 상황에 어떻게 대응해야 할까? 앱을 대신하는 대체 모바일 웹 페이지로 보내주거나 앱을 설치할 수 있는 스토어로 보내줘야 하는데, 만약 다음과 같이 페이지 이동을 하려 했다면 골치가 아플 것이다.

```javascript
location.href = "youtube://watch?v=w66Kzs7UIHk";
// Do nothing
```

`youtube`를 실행할 수 있는 네이티브 어플리케이션이 없다면 위 코드의 실행 후 웹 페이지에선 아무런 일도 일어나지 않는다. 에러조차 발생하지 않기 때문에, 이 실행이 실패했다는 것을 상정하는 방식은 다음과 같은 코드가 제안된다.

```javascript
location.href = "youtube://watch?v=w66Kzs7UIHk";

// 윗 줄에서 새 페이지로 전환이 되었다면 자바스크립트 실행이 안될 건데 이 타임아웃이 동작했다는 것은
// 필시 어플리케이션이 제대로 실행되지 않았다는 의미일 것이다.
setTimeout(function () {
  // 어플리케이션 이동은 포기하고 웹 페이지로 이동
  location.href = "https://www.youtube.com/watch?v=w66Kzs7UIHk";
}, 2000); // 대충 적당한 시간을 기다려봄
```

이런 썩 마음에 들지 않는 코드 말고도 또 다른 문제가 있다. 공식적으로 등록되지 않은 스킴이란 말은 언제든 중복이 발생할 수 있다는 의미를 내포한다는 점이다. 

<p class="center rounded-edge-16 w-half">
  <img src="https://i.postimg.cc/HjDPgGc6/image.png" alt="중복 스킴" />
</p>

예를 들어 `store`라는 스킴을 가진 어플리케이션이 여럿이라면 위와 같이 사용자에게 셋 중 하나를 선택하라는 UI가 노출되어야 한다. 사소해 보여도 이런 것 하나하나가 모여서 사용자의 귀찮음을 만드는 것이다. 실수로 "항상" 버튼을 한 번 눌렀다가 다음번에 다른 앱으로 링크를 열어야 할 때 곤란해질 수도 있다. 이런 중복 문제는 앱이 기기에 설치되지 않았을 때 자연스럽게 앱 설치를 유도하기도 어렵게 만든다. 사람이야 딱 보면 알겠지만 사전 정보가 하나도 없는 OS 입장에선 "아니 `youtube`라는 스킴은 뭘로 실행해야 하는 거야? 마켓에서 무슨 어플을 받아야 하는거야?"라는 고민에 빠지게 된다.

#### 도메인 기반 딥 링크

하지만 다행히도 웹을 기반으로 제공되는 서비스라면 하나쯤 고유 식별자를 가지고 있기 마련이다. <strong>도메인 네임(Domain Name)</strong>은 특정 서비스를 식별하는 고유한 문자열을 뜻한다. <a href="blog.anteater-lab.link">https://blog.anteater-lab.link/</a> 이 그 문자열이 대표적인 사례. 이 역시 IANA에서 관리하고 있는 자원 중 하나임과 동시에, 스킴과 달리 웹 서비스와 1대1로 연결되는 고유성을 갖고 있다는 특징이 있다. 그만큼 귀중한 자원이라 공짜로는 쉽게 쓰기 어렵고, 나도 이 블로그를 위해 매달 거금 0.5$를 AWS에게 바치고 있다. 요즘 환율도 안 좋은데 말이야.

아무튼 웹 서비스 입장에서 이왕 이렇게 비싼 귀중품 하나씩은 마련해야만 하는 처지에 그걸 더 잘 써보면 좋지 않을까 라는 것이다. 말한 대로 도메인 네임은 고유하기 때문에 도메인 네임을 기반으로 딥 링크를 구현하면 스킴 중복 문제에서 자유로워진다. 또한 그 링크를 사용하는 입장에서도 굳이 어플리케이션 진입을 위해 앱 스킴이 포함된 별도의 링크 문자열로 분기 처리를 할 필요가 없게 된다. 

<p class="w-3-quarter center">
  <img src="https://i.postimg.cc/tghPTSQL/image.png" alt="denied" />
</p>

여기서 중요한 것은 불필요한 네트워크 요청이 발생하지 않게 만드는 것이다. 웹 브라우저의 동작을 유도하든, OS의 동작을 유도하든, JS로 직접 구현을 하든 어쨌든 웹 페이지를 진입한 다음에야 상황을 판별해 앱을 실행하는 것은 바람직하지 않다. OS에서 "이 도메인의 URL은 유튜브 앱을 실행하면 된다" 같은 정보를 알고 있다면 굳이 웹 페이지에 대한 불필요한 요청을 보낼 필요도 없이 앱을 실행할 수 있다. 그것을 위해서 웹 서버와 도메인이 필요하다. 웹 서버를 사용하지 않기 위해 웹 서버가 필요한 아이러니한 상황.

- Android(App Links): https://domain.name/.well-known/<strong>assetlinks.json</strong>
- IOS(Universal Links): https://domain.name/.well-known/<strong>apple-app-site-association</strong>

이처럼 특정 도메인과 특정 어플리케이션을 직접 연결하는 방법을 안드로이드 진영에선 <strong>앱 링크(App Links)</strong>라고 부르고, IOS에선 <strong>유니버설 링크(Universal Links)</strong>라고 부른다. `assetlinks.json` 파일 또는 `apple-app-site-association` 파일을 우리 웹 서버에 등록해둔 다음 앱 설치 시 이 파일들을 참고하도록 연결하는 방식이다. 각 두 파일의 상세한 내용은 조금씩 다르지만 공통적으로 앱과 도메인의 연결이 신뢰할 수 있다는 것을 증명하는 역할을 한다. 따라서 OS는 앱 설치 시점에 이 파일들을 캐싱해두고, 앞으로 사용자의 브라우징 동안 OS에 등록된 경로로 진입이 발생할 때 서버로 요청을 보내는 것이 아닌 앱으로 안전하게 바로 진입할 수 있도록 만 들 수 있는 것이다.

### 딥 링크 흘리기

<p class="w-3-quarter center">
  <img src="https://i.postimg.cc/zfgmRhxm/image.png" alt="하지만 때론"/>
  <br/>
  하지만 때론 이런 상황이 올 때도 있다.
</p>

이번 글에선 조금 독특한 상황에 대해 다뤄볼 것이다. 딥 링크 편한 것은 알겠지만, 아주 가끔 그 동작이 필요하지 않은 순간이 오기도 한다. 가령 구글이나 애플에게 수수료가 떼이는 것이 마음에 들지 않아 사용자들이 결제 페이지에 있어서는 모바일 웹 페이지를 사용하도록 교묘히 유도할 수도 있다. 그런데 말했듯이 딥 링크는 조금 더 편한 사용자 경험을 위한 기능이며, 별도의 얼럿 UI 출력 없이 모바일 웹과 앱 간의 전환이 자연스러울수록 더 편한 사용자 경험이 될 것이다. <strong><i>그래서 결제 페이지로 향하는 버튼을 눌렀더니 딥 링크 설정에 의해 앱이 강제 실행되어버린다면?</i></strong> 물론 딥 링크 설정 시 어떤 경로에서 딥 링크가 동작해야 하는지 설정하는 옵션은 제공된다. 하지만 어떤 사유로 인하여 과거에 모든 경로에서 딥 링크가 동작하도록 설정이 되었고, 신규 기능의 서비스 배포 데드라인이 코 앞인 상황이라면 여유롭게 이 파일을 수정하고 있을 순 없다.

<p class="center">
  <img src="https://i.postimg.cc/4d32Myxz/image.png" alt="요청"/>
</p>

우선 현실적인 문제는 이런 설정 파일의 변경이 서비스에 즉시 반영되지 않는다는 것이다. 앞서 설명했듯 딥 링크 설정은 앱의 설치 시점에 사용자의 기기에 저장되어 불필요한 추가 요청을 만들지 않는 구조이기 때문이다. 심지어 애플이 제공하는 안내사항에선 요청이 우리 웹 서버로 바로 가는 것이 아니라 애플의 CDN으로 간다고 설명하고 있다. 모든 사용자의 어플리케이션을 강제 업데이트 하면 가능할지도 모르지만 고작 이런 일에 사용하기엔 리스크가 큰 작업이다.

두 번째 문제로는 사실 기술적인 이유보단, 딥 링크라는 동작 자체가 여러 유관 부서들 사이에 위치하는 종류의 작업이란 점이다. 이건 레거시와 히스토리가 적잖이 쌓여있는 현 회사에서만 겪을법한 특수 상황에 가깝다. 우선 딥 링크 설정이 왜 그렇게 되었는지부터 파악을 해야 하며, 앱 개발 부서에겐 앱 사용을 막기 위한 앱 업데이트를 요청해야 한다. 이런 정책적으로 골치아픈 상황을 피하기 위해 FE 개발자는 딥 링크를 어떻게든 우회한다는 행복 버튼을 눌러버리는 것이다. 이 참에 내가 이 글을 쓰게 된 이유를 설명하자면, 실제로 전혀 예상하지 못했던 이슈가 배포 일정 직전에 튀어나와 당시 큰 패닉에 빠졌었기 때문이다. 당시 패닉 속에서 머리를 열심히 굴려 얻어낸 결론은 다음과 같다. 도메인 기반의 딥 링크 동작은 OS가 버튼 터치 따위의 사용자 입력을 하이재킹해 실행되는 것이다. 그럼 사용자 입력이 아니면 되잖아?

```html
<!-- 이 링크를 클릭 시 앱 강제 진입이 발생했다. -->
<a href="https://m.anteater-lab.link/payments">결제하기</a>

<!-- 그럼 이런 경로를 만들어주면 어떨까? -->
<a href="https://anteater-lab.link/bridge?url=https://m.anteater-lab.link/payments">결제하기</a>
```


1. 강제 발동 조건
   1. IOS 한정으로만 발견됨, 버튼 터치 등 사용자 액션으로 인한 페이지 이동 시 발생, 동일 도메인에서 이동하는 경우에는 미동작.
2. 프론트 소스에서 새 라우트를 파서 쿼리로 URL을 받으면 페이지 진입과 동시에 리다이렉션 시켜줌
3. 디테일을 살려 location.href.replace()

앱으로 열기 팝업이 뜰 경우 YES로 해버리면 그 설정이 저장되어서 다음부턴 자동 진입이 되어버리나봄

궁금한 것 : 왜 아무런 유저 요청 없이 바로 앱 진입이 되어버리는가? IOS만 그러는가? 안드에서 그런 상황?
- GPT 설명으론 안드로이드에선 브라우저가 개입을 한다는데.. 좀 더 검증 필요함. 무엇보다 패스 설정이 정말 /로 되어있는지 여부는 매니페스토에 있기 때문에 확인할 길이 없음..


며칠 고민 끝에 여기 저기 문의드린 결과 떠올린 아이디어. 그럼... 사용자의 이동이 아니면 되잖아?

(구체적인 해결 과정 작성)
개발자로서 우리 웹 앱에 더미 라우트 하나 파는 것은 가능했음  
URL 파라미터로 타겟 URL을 주면 자동 리다이렉트 해주는 라우트를 생성.

`location.replace()`를 해야 깔끔하게 리다이렉트 됨

솔직히 될 줄 몰랐는데 되더라...

말 그대로 흘리기.

하지만 이 또한 결국 임시방편.
  - 일례로, 이러한 이슈를 보고드린 직장 동료분에게도 과거 비슷한 경험이 있어 당시 해결했던 방법을 추천받았으나 현재 시점으로 애플이 막았나봄...
  - 이렇게 리다이렉트해도 뜨는 팝업에서 사용자가 앱으로 열기 YES 해버리면 안되고, 그리고 심지어 한차례는 팝업이 떠도 강제 앱 진입이 되어버리긴 함

결국은 정책을 잘 조정해보자. 당신이 유니버설 링크 설정을 변경할 수 있다면 말이지.

## 내가 배운 것

앱 스킴이 유용한 순간은 네이티브 앱과 웹뷰가 혼용되어서 사용될 때.

- IOS 기기 구매 고민 강하게 하는 중
  - 이런 이슈 때문에 야근할 바에... 테스트 기기좀 마련해두면 좋지..
- Safari 버전 강제도 최근 상당히 짜증나는 부분 중 하나.