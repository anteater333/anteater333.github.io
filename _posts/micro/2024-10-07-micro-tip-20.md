---
layout: post
title: "자잘한 도움말 #20 Next.js SSG에서 시스템 다크 모드 설정 가져오기"
subtitle: "그리고 블로그 Ver.3 패치 노트"
description: ""
date: 2024-10-07 21:55:00 +0900
category: micro

id: 20
slug: system-theme-in-nextjs
tags: [💡, Front-end, React, Next.js, Web Browser]

# coverImage: "/assets/blog/coverImages/micro-20.png"

# ogImage:
#   url: "/assets/blog/coverImages/micro-20.png"
---

## TL;DR

## 이하 그리 중요하진 않은 내용들

### 블로그 재건축

<p class="center w-3-quarter">
<img src="https://i.postimg.cc/Y9pPpccZ/image.webp" alt="정상영업합니다" />
</p>

약 2달 전, 워낙 방문자 수가 적은 블로그라서 아무도 알아차리지 못했을 테지만, <a target="_blank" class="a-not-colored" href="/meta/2/welcome-to-next">기존 Jekyll로 구축했던 블로그를 Next.js와 React 기반으로 리모델링했다</a>. 손수 디자인까지 하는 등 밑바닥부터 새로 만든다고 고생 깨나 했다. 외관도 신상, 소스 코드도 신상. 아주 따끈따끈한 블로그가 되었다. <i>"이게 갈아엎은 거라고?"</i> 라는 생각은 뒤로 넣어두시고, 이번 글에선 새 블로그를 만들며 겪은 어려웠던 점과 함께 <a target="_blank" href="/category/micro">자잘한 도움말</a> 카테고리의 20회를 축하하는 의미로 새 기능들에 대해서도 소개하고자 한다.

### Ver.3 패치 노트

#### 게시글 URL이 변경되었습니다.

- 기존 URL: <a target="_blank" href="/micro/2024/04/23/micro-tip-15.html">https://blog.anteater-lab.link/micro/2024/04/23/micro-tip-15.html</a>
- 신규 URL: <a target="_blank" href="/micro/15/node-version-manager">https://blog.anteater-lab.link/micro/15/node-version-manager</a>

블로그를 운영하면 가장 많이 신경쓰게 되는 부분이 SEO(Search Engine Optimization, 검색 엔진 최적화)다. 글을 아무리 많이 쓰고, 도네이션 버튼이나 광고를 아무리 많이 달아도 결국 구글 검색에 노출되지 않으면 말짱 꽝. 하지만 신경 쓴다고 항상 잘 되는건 아니기 마련이라 스스로 "어차피 내가 보려고 글 쓰는거야"라고 위로해왔지만, 그래도 좋은게 좋은거지. 그래서 이번에 SEO에 도움이 될 변화를 도입하게 되었다.

<strong>슬러그(Slug)</strong>란, 일반적으로 URL의 끝에 포함되는 웹 주소의 식별자 부분이다. 이전 버전에선 이 부분이 아주 사무적이고 딱딱하게 작성되고 있었다. URL 주소 또한 검색 엔진이 크롤링하는 요소들 중 하나이다. 그만큼 사용자 친화적인 슬러그가 SEO에 도움된다고 한다. 최대한 5 단어가 넘지 않도록 짧고 간결하게, 하지만 이 페이지의 핵심 내용을 담고 있도록 모든 기존 작성글에 신규 슬러그를 부여하였다.

<p class="center rounded-edge-16">
<img src="https://i.postimg.cc/g0wYC7yd/image.png" />
</p>

그리고 단순히 URL이 변경되었다는 사실 보다 중요한 것. 수 년간 사용해왔던 URL을 하루아침에 버릴 순 없었다. <span class="line-through">(혹시 모를)</span> 기존 사용자들이 내 글을 링크 해놓거나 북마크 해뒀을 수도 있잖아. 그래서 신규 URL을 적용함과 동시에 기존 방식의 URL 목록을 자동 생성하는 스크립트를 작성했으며, 과거 URL로 접속한 사용자를 자동으로 신규 URL로 리다이렉션 해주는 페이지를 생성하도록 기능을 구현했다. 이렇게 레거시 지원에도 게을리 하지 않는 Anteater's laboratory가 되겠습니다 여러분.

#### 예상 완독 시간이 추가되었습니다.

<p class="center rounded-edge-16">
<img src="https://i.postimg.cc/3N02fh9G/ETR.png" />
</p>

여러 블로그를 방문하며 눈독 들이고 있던 기능이었다. 멋있잖아. 멋도 멋인데, 나름 대시보드 서비스를 개발했던 사람으로서 이런 인사이트의 힘을 중요하게 생각하기 때문에 적극적으로 도입하게 되었다. 계산식에는 인터넷에 공개된 논문(<a href="https://www.jkos.org/upload/pdf/JKOS057-04-17.pdf">「한국어 읽기 속도 측정 애플리케이션의 유효성 및 정상인의 읽기 속도에 대한 사전 연구」, 대한안과학회지, 2016</a>)을 참고하였다. 대신 WPM(Words Per Minutes) 수치 정도만 참고했고, 이미지와 코드 수는 어림잡아서...

#### 태그 시스템이 추가되었습니다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/pdHWjKyz/TAGS.png" />
</p>

기존 블로그에선 게시글을 카테고리 단위로만 분류하고 있었다. "자잘한 도움말", "독후감", "Not 4 Dev" 등등. 하지만 카테고리는 글의 형태에 따른 분류일 뿐. 내가 워낙 좋게 말하면 풀스택, 나쁘게 말하면 이도저도 아닌 개발 커리어를 쌓고 있는 중이기 때문에 한 카테고리 안에서도 주제가 다양했다. 그래서 주제에 따라 게시글 목록을 분류할 수 있도록 태그 시스템을 구현했다.

- 태그 적용 URL: <a href="https://blog.anteater-lab.link/?tags=Front-end">https://blog.anteater-lab.link/?tags=Front-end</a>

기존 게시글 모두에 태그를 부여했으며, 태그를 통해 게시글을 필터링 할 수 있는 기능도 구현했다. 필터 컴포넌트 구현에 어려움은 없었는데 한 50년 쯤 뒤에 게시글이 500개가 넘어가면 어떻게 해야하나 고민 중.

#### Buy Me A Coffee 버튼이 더 화려해졌습니다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/FR6wyQG8/bmc.webp" />
</p>

가난한 개발자는 커피 마실 돈이 필요해요. 하지만 글쏨씨가 미려하지도 않고, 기술적으로 아주 깊은 통찰을 보여주지도 않는데다 창의성도 부족한 이 블로그에서 저 버튼을 기꺼이 누를 사람이 얼마나 있을까. 버튼에 눈길이라도 한 번 주십사 재롱을 좀 부려봤다. 여전히 마감 처리는 마음에 들지 않는다.

#### 기본 모드와 다크 모드, 두 가지 테마를 지원합니다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/QxfY1Dtb/dark.webp" />
</p>

기존 블로그엔 어두운 색상을 사용 했었다. 개발자의 친구 다크 모드지만 역시 칙칙해. 신규 블로그에선 디자인을 산뜻한 흰색 바탕으로 꾸며보았다. 하지만 이걸로 끝낼 순 없지, 테마 시스템을 적용해 흰색 배경의 기본 모드와 검은색 배경의 다크 모드를 모두 지원 가능하도록 구현했다. 이제 새벽에 불 꺼놓고 몰래 블로그 보다가 안구 테러 당할 일 없다구.

### 시스템 다크모드 설정 가져오기

### 클라이언트 컴포넌트 안에 서버 컴포넌트가 들어가는 상황?

## 내가 배운 것

ref
https://seo.tbwakorea.com/blog/what-is-slug/

https://www.inflearn.com/community/questions/1118233/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9E%90%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%84%A3%EC%97%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A7%88%EB%AC%B8%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4?srsltid=AfmBOoq8paJs7TAe8CSepB6O-JT8JN7TCWH3Bk9xs4guynaFqMEEAOsn

https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns

----

- 주제를 어디에 중점을 둘 것인가
  - 다크모드 설정하는 방법?
  - SSG 개발 시 발생할 수 있는 문제점?
  - 상태관리 라이브러리 사용 변천사?
- 일단 주제는 Nextjs SSG에 초점을 둡시다.
  - 기존 블로그를 바꾼 이유
  - 왜 Nextjs인가
  - 왜 SSG인가
  - SSG로 개발하면서 골치아팠던 문제
    - 빌드시점 상태와 클라이언트의 상태가 다른 현상
      - 이게 왜 문제가 되는가? 도 조사할 것.

- 페이지 로드 시 시스템 다크모드 설정을 가져와 페이지에 먼저 적용하고 싶은데
  - useStore등의 기능은 hook으로, 클라이언트사이드 기능
  - registry 모듈을 통해 페이지 로드 시의 초기 세팅을 설정한다.
  - 근데 그럼 결국 registry들은 클라이언트 컴포넌트들?
  - 클라이언트 컴포넌트 안에 서버 컴포넌트가 들어가는 구조가 괜찮은가요?
  - https://www.inflearn.com/community/questions/1118233/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9E%90%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%84%A3%EC%97%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A7%88%EB%AC%B8%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4?srsltid=AfmBOoq8paJs7TAe8CSepB6O-JT8JN7TCWH3Bk9xs4guynaFqMEEAOsn
  - When a new request is made to the server, all Server Components are rendered first, including those nested inside Client Components.
    - https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns


- 실제 사용 코드

```javascript
import { useEffect } from "react";
import { create } from "zustand";

type Store = {
  isDarkMode: boolean;
  toggleDark: () => void;
  setIsDarkMode: (isDarkMode: boolean) => void;
};

const useStore = create<Store>()((set) => {
  return {
    isDarkMode: false,
    toggleDark: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
    setIsDarkMode: (isDarkMode) => set((state) => ({ isDarkMode })),
  };
});

export const useDarkMode = () => {
  const { isDarkMode, toggleDark, setIsDarkMode } = useStore();

  // useStore에서 바로 window 객체의 존재 여부를 파악하며 isDarkMode를 결정지을 경우
  // 서버사이드 렌더링과 클라이언트 사이드 렌더링의 초기 상태 차이로 인해 오류를 발생시킴
  // 먼저 상태 생성 후 -> useEffect 훅으로 시스템 설정을 확인
  useEffect(() => {
    const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");
    const updateDarkMode = (e: MediaQueryListEvent) => {
      setIsDarkMode(e.matches);
    };

    // 초기 상태 설정
    setIsDarkMode(mediaQueryList.matches);

    // 리스너 등록
    mediaQueryList.addEventListener("change", updateDarkMode);

    // 컴포넌트 언마운트 시 리스너 제거
    return () => {
      mediaQueryList.removeEventListener("change", updateDarkMode);
    };
  }, []);

  return { isDarkMode, toggleDark };
};

export default useStore;
```
