---
layout: post
title: "자잘한 도움말 #20 Next.js SSG에서 시스템 테마 가져오기"
subtitle: "그리고 블로그 Ver.3 패치 노트"
description: ""
date: 2024-10-07 21:55:00 +0900
category: micro

id: 20
slug: system-theme-in-nextjs
tags: [💡, Front-end, React, Next.js, Web Browser]

# coverImage: "/assets/blog/coverImages/micro-20.png"

# ogImage:
#   url: "/assets/blog/coverImages/micro-20.png"
---

## TL;DR

## 이하 그리 중요하진 않은 내용들

### 블로그 재건축

<p class="center w-3-quarter">
<img src="https://i.postimg.cc/Y9pPpccZ/image.webp" alt="정상영업합니다" />
</p>

약 2달 전, 워낙 방문자 수가 적은 블로그라서 아무도 알아차리지 못했을 테지만, <a target="_blank" class="a-not-colored" href="/meta/2/welcome-to-next">기존 Jekyll로 구축했던 블로그를 Next.js와 React 기반으로 리모델링했다</a>. 손수 디자인까지 하는 등 밑바닥부터 새로 만든다고 고생 깨나 했다. 외관도 신상, 소스 코드도 신상. 아주 따끈따끈한 블로그가 되었다. <i>"이게 갈아엎은 거라고?"</i> 라는 생각은 뒤로 넣어두시고, 이번 글에선 새 블로그를 만들며 겪은 어려웠던 점과 함께 <a target="_blank" href="/category/micro">자잘한 도움말</a> 카테고리의 20회를 축하하는 의미로 새 기능들에 대해서도 소개하고자 한다.

### Ver.3 패치 노트

#### 게시글 URL이 변경되었습니다.

- 기존 URL: <a target="_blank" href="/micro/2024/04/23/micro-tip-15.html">https://blog.anteater-lab.link/micro/2024/04/23/micro-tip-15.html</a>
- 신규 URL: <a target="_blank" href="/micro/15/node-version-manager">https://blog.anteater-lab.link/micro/15/node-version-manager</a>

블로그를 운영하면 가장 많이 신경쓰게 되는 부분이 SEO(Search Engine Optimization, 검색 엔진 최적화)다. 글을 아무리 많이 쓰고, 도네이션 버튼이나 광고를 아무리 많이 달아도 결국 구글 검색에 노출되지 않으면 말짱 꽝. 하지만 신경 쓴다고 항상 잘 되는건 아니기 마련이라 스스로 "어차피 내가 보려고 글 쓰는거야"라고 위로해왔지만, 그래도 좋은게 좋은거지. 그래서 이번에 SEO에 도움이 될 변화를 도입하게 되었다.

<strong>슬러그(Slug)</strong>란, 일반적으로 URL의 끝에 포함되는 웹 주소의 식별자 부분이다. 이전 버전에선 이 부분이 아주 사무적이고 딱딱하게 작성되고 있었다. URL 주소 또한 검색 엔진이 크롤링하는 요소들 중 하나이다. 그만큼 사용자 친화적인 슬러그가 SEO에 도움된다고 한다. 최대한 5 단어가 넘지 않도록 짧고 간결하게, 하지만 이 페이지의 핵심 내용을 담고 있도록 모든 기존 작성글에 신규 슬러그를 부여하였다.

<p class="center rounded-edge-16">
<img src="https://i.postimg.cc/g0wYC7yd/image.png" />
</p>

그리고 단순히 URL이 변경되었다는 사실 보다 중요한 것. 수 년간 사용해왔던 URL을 하루아침에 버릴 순 없었다. <span class="line-through">(혹시 모를)</span> 기존 사용자들이 내 글을 링크 해놓거나 북마크 해뒀을 수도 있잖아. 그래서 신규 URL을 적용함과 동시에 기존 방식의 URL 목록을 자동 생성하는 스크립트를 작성했으며, 과거 URL로 접속한 사용자를 자동으로 신규 URL로 리다이렉션 해주는 페이지를 생성하도록 기능을 구현했다. 이렇게 레거시 지원에도 게을리 하지 않는 Anteater's laboratory가 되겠습니다 여러분.

#### 예상 완독 시간이 추가되었습니다.

<p class="center rounded-edge-16">
<img src="https://i.postimg.cc/3N02fh9G/ETR.png" />
</p>

여러 블로그를 방문하며 눈독 들이고 있던 기능이었다. 멋있잖아. 멋도 멋인데, 나름 대시보드 서비스를 개발했던 사람으로서 이런 인사이트의 힘을 중요하게 생각하기 때문에 적극적으로 도입하게 되었다. 계산식에는 인터넷에 공개된 논문(<a href="https://www.jkos.org/upload/pdf/JKOS057-04-17.pdf">「한국어 읽기 속도 측정 애플리케이션의 유효성 및 정상인의 읽기 속도에 대한 사전 연구」, 대한안과학회지, 2016</a>)을 참고하였다. 대신 WPM(Words Per Minutes) 수치 정도만 참고했고, 이미지와 코드 수는 어림잡아서...

#### 태그 시스템이 추가되었습니다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/pdHWjKyz/TAGS.png" />
</p>

기존 블로그에선 게시글을 카테고리 단위로만 분류하고 있었다. "자잘한 도움말", "독후감", "Not 4 Dev" 등등. 하지만 카테고리는 글의 형태에 따른 분류일 뿐. 내가 워낙 좋게 말하면 풀스택, 나쁘게 말하면 이도저도 아닌 개발 커리어를 쌓고 있는 중이기 때문에 한 카테고리 안에서도 주제가 다양했다. 그래서 주제에 따라 게시글 목록을 분류할 수 있도록 태그 시스템을 구현했다.

- 태그 적용 URL: <a href="https://blog.anteater-lab.link/?tags=Front-end">https://blog.anteater-lab.link/?tags=Front-end</a>

기존 게시글 모두에 태그를 부여했으며, 태그를 통해 게시글을 필터링 할 수 있는 기능도 구현했다. 필터 컴포넌트 구현에 어려움은 없었는데 한 50년 쯤 뒤에 게시글이 500개가 넘어가면 어떻게 해야하나 고민 중.

#### Buy Me A Coffee 버튼이 더 화려해졌습니다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/FR6wyQG8/bmc.webp" />
</p>

가난한 개발자는 커피 마실 돈이 필요해요. 하지만 글쏨씨가 미려하지도 않고, 기술적으로 아주 깊은 통찰을 보여주지도 않는데다 창의성도 부족한 이 블로그에서 저 버튼을 기꺼이 누를 사람이 얼마나 있을까. 버튼에 눈길이라도 한 번 주십사 재롱을 좀 부려봤다.

#### 기본 모드와 다크 모드, 두 가지 테마를 지원합니다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/hvYk2MVD/dark.webp" />
</p>

기존 블로그엔 어두운 색상을 사용 했었다. 개발자의 친구 다크 모드지만 역시 칙칙해. 신규 블로그에선 디자인을 산뜻한 흰색 바탕으로 꾸며보았다. 하지만 이걸로 끝낼 순 없지, 테마 시스템을 적용해 흰색 배경의 기본 모드와 검은색 배경의 다크 모드를 모두 지원 가능하도록 구현했다. 이제 새벽에 불 꺼놓고 몰래 블로그 보다가 안구 테러 당할 일 없다구.

### 웹에서 다크 모드 구현하기

오늘은 위에 나열한 변경점 중 다크 모드에 대해서 한 번 다뤄보자. 사이트의 핵심 까지는 아니지만 없으면 눈이 아파 신경 쓰이는 이것. 웹 페이지에서 다크 모드는 어떻게 구현해야 할까? 일단 기본적으로 다크 모드와 같은 <strong>테마(Theme)</strong> 기능은 GUI의 스타일 영역에 포함되는 만큼 CSS를 기반으로 구현하면 된다. CSS에선 <strong>미디어 쿼리</strong>에 다음과 같은 규칙을 지원한다.

<p class="center">
<a href="https://developer.mozilla.org/ko/docs/Web/CSS/@media/prefers-color-scheme">
<code><strong class="middle-big">prefers-color-scheme</strong>
</code>
</a>
<br/>
사용자의 시스템이 라이트와 다크 중 어떤 테마를 사용하는지 탐지한다.
<br/>
</p>

```css
/* 시스템이 다크 모드일 때 */
@media (prefers-color-scheme: dark) {
  body {
    background: black;
    color: white;
  }
}

/* 시스템이 라이트 모드일 때 */
@media (prefers-color-scheme: light) {
  body {
    background: white;
    color: black;
  }
}
```

일종의 반응형 디자인 구현이라고 볼 수 있다. 반응하는게 뷰포트의 크기가 아니라 시스템의 테마일 뿐. 하지만 이 방식 만으로 다크 모드를 구현하는건 비추천한다. 첫째 이유는 레거시 지원. Web API 관련 글을 쓸 때마다 비슷한 이야기를 반복하는 것 같다. 2010~2020년대 쯤 처음 소개된 웹 기반 기술을 다룰 땐 2024년 현재 기준 과거 버전의 웹 브라우저에서 잘 동작하지 않을 수 있다는 사실을 염두에 둬야 한다.

<p class="center rounded-edge-16 w-3-quarter">
<img src="https://i.postimg.cc/wxssryfx/image.png"/>
</p>

물론 왠만한 상황에선 동작하긴 한다. 하지만 이 방식엔 또 다른 문제도 있다. 오직 시스템의 설정에 따라서만 웹 앱의 테마가 결정된다는 것. 이 방식에선 웹 앱 자체적으로 테마를 변경할 수 없다. 현재 내 블로그 우측 하단에 존재하는 테마 변경 버튼 같은 기능을 구현하려면 어떻게 해야 할까.

```css
/* CSS */
body.dark {
  background: black;
  color: white;
}

body.light {
  background: white;
  color: black;
}
```
```javascript
// JavaScript

// 다크 모드로 전환
window.document.body.classList.add('dark');
window.document.body.classList.remove('light');

// 라이트 모드로 전환
window.document.body.classList.add('light');
window.document.body.classList.remove('dark');
```

최상위 엘리먼트(`<body>` 혹은 의사 클래스 `:root`에 해당하는 엘리먼트)에 테마를 설정하는 클래스를 동적으로 제어해주면 된다. 이렇게 JavaScript가 개입할 수 있게 되면 다양한 가능성이 발생한다. 첫 번째 방식과 조합해 편의성을 조금 더 높혀볼 수도 있다.

```javascript
// JavaScript에서 Media query를 확인해 시스템 테마가 바뀔때 마다 자동으로 웹 페이지의 테마를 바꾼다.
window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (event) => {
  if (e.matches) {
    window.document.body.classList.add('dark');
    window.document.body.classList.remove('light');
  } else {
    window.document.body.classList.add('light');
    window.document.body.classList.remove('dark');
  }
});
```

웹 페이지가 복잡해질수록 다크 모드의 영향을 받는 엘리먼트도 늘어날 것이다. 일일이 CSS에서 직접 하나하나 다크 모드와 라이트 모드 속성을 구분해주긴 귀찮으니 다음과 같이 CSS 전역 변수를 설정하는 것이 좋다.

```css
body.dark {
  --bg-color-main: black;
  --text-color-main: white;
  --text-color-sub: #ddd;
}

body.light {
  --bg-color-main: white;
  --text-color-main: black;
  --text-color-sub: #333;
}

.my-container {
  background-color: var(--bg-color-main);
  color: var(--text-color-main);
}
```




- prefers-color-scheme 
- body 태그에 적용
- CSS Var

사이트가 복잡해지면서 다크 모드 상태를 바라봐야 하는 컴포넌트들도 많아짐 -> 자연스럽게 전역 상태와 맞닿게 되는 기능.
< 여기까지 원론적 이야기

블로그에 적용한 방법 >

블로그에는 Styled-component와 Zustand가 사용되었다.
Styled-component의 테마 기능을 사용, 전역 테마 상태는 Zustand로 관리.
toggleDark 함수는 토글 버튼에서 사용하면 됨.
기본적으로 최상위 컴포넌트에서 상태 변경에 따라 CSS Var를 변경하기 때문에 직접 isDarkMode를 건드리는 컴포넌트는 많지 않다.
하지만 다크 모드에 따라 아이콘 리소스 자체가 바껴야 하는 경우엔 직접 전역 상태를 읽어오기도 함.

조금 더 편의성을 높여보자. 사용자가 직접 컨트롤 하는 것 보단, 똑똑한 사이트가 알아서 사용자의 설정에 맞춰 다크 모드로 변경해놓으면 더 좋다.

앞서 방법 중 하나 prefers-color-scheme (이 media query에 스타일을 작성하는건 비추지만)

이걸 커스텀 훅으로 묶어서 레지스트리에서 실행해주면 된다.

### 클라이언트 컴포넌트 안에 서버 컴포넌트가 들어가는 상황?

레지스트리와 클라이언트 컴포넌트/서버 컴포넌트의 차이에 대해

둘의 포함 관계에 따른 동작 변화는 어떻게 되는가?

## 내가 배운 것

ref
https://seo.tbwakorea.com/blog/what-is-slug/

https://www.inflearn.com/community/questions/1118233/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9E%90%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%84%A3%EC%97%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A7%88%EB%AC%B8%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4?srsltid=AfmBOoq8paJs7TAe8CSepB6O-JT8JN7TCWH3Bk9xs4guynaFqMEEAOsn

https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns

https://fe-developers.kakaoent.com/2021/211118-dark-mode/

----

- 주제를 어디에 중점을 둘 것인가
  - 다크모드 설정하는 방법?
  - SSG 개발 시 발생할 수 있는 문제점?
  - 상태관리 라이브러리 사용 변천사?
- 일단 주제는 Nextjs SSG에 초점을 둡시다.
  - 기존 블로그를 바꾼 이유
  - 왜 Nextjs인가
  - 왜 SSG인가
  - SSG로 개발하면서 골치아팠던 문제
    - 빌드시점 상태와 클라이언트의 상태가 다른 현상
      - 이게 왜 문제가 되는가? 도 조사할 것.

- 페이지 로드 시 시스템 다크모드 설정을 가져와 페이지에 먼저 적용하고 싶은데
  - useStore등의 기능은 hook으로, 클라이언트사이드 기능
  - registry 모듈을 통해 페이지 로드 시의 초기 세팅을 설정한다.
  - 근데 그럼 결국 registry들은 클라이언트 컴포넌트들?
  - 클라이언트 컴포넌트 안에 서버 컴포넌트가 들어가는 구조가 괜찮은가요?
  - https://www.inflearn.com/community/questions/1118233/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9E%90%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%84%A3%EC%97%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%A7%88%EB%AC%B8%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4?srsltid=AfmBOoq8paJs7TAe8CSepB6O-JT8JN7TCWH3Bk9xs4guynaFqMEEAOsn
  - When a new request is made to the server, all Server Components are rendered first, including those nested inside Client Components.
    - https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns

- 카카오 FE 블로그  
  https://fe-developers.kakaoent.com/2021/211118-dark-mode/
  prefers-color-scheme 기반으로 다크모드를 구현하는건 비추한다고 함

하지만, 이 방법은 한계점이 명확합니다.
시스템이 컬러모드 설정을 지원하지 않는 경우 대응할 수 없습니다 (ios 13 미만, Android 10 미만 등)
자체적인 컬러모드 정책을 가져갈 수 없습니다 (항상 시스템의 결정에 따라 컬러모드가 결정됩니다)
카카오페이지 웹은 앱 내 웹뷰로도 사용되는 경우가 종종 있기 때문에, 때로는 앱의 다크모드 설정을 따라야 하는 경우가 생깁니다.
게다가 구버전 Android os를 사용하는 유저도 상당 수 있는 상태라서 Android 10 미만을 지원하지 않는 것은 치명적입니다.
그래서 저희는 이 방식을 채택할 수 없었고, 사용하시는 걸 추천하지 않습니다.


- 실제 사용 코드

```javascript
import { useEffect } from "react";
import { create } from "zustand";

type Store = {
  isDarkMode: boolean;
  toggleDark: () => void;
  setIsDarkMode: (isDarkMode: boolean) => void;
};

const useStore = create<Store>()((set) => {
  return {
    isDarkMode: false,
    toggleDark: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
    setIsDarkMode: (isDarkMode) => set((state) => ({ isDarkMode })),
  };
});

export const useDarkMode = () => {
  const { isDarkMode, toggleDark, setIsDarkMode } = useStore();

  // useStore에서 바로 window 객체의 존재 여부를 파악하며 isDarkMode를 결정지을 경우
  // 서버사이드 렌더링과 클라이언트 사이드 렌더링의 초기 상태 차이로 인해 오류를 발생시킴
  // 먼저 상태 생성 후 -> useEffect 훅으로 시스템 설정을 확인
  useEffect(() => {
    const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");
    const updateDarkMode = (e: MediaQueryListEvent) => {
      setIsDarkMode(e.matches);
    };

    // 초기 상태 설정
    setIsDarkMode(mediaQueryList.matches);

    // 리스너 등록
    mediaQueryList.addEventListener("change", updateDarkMode);

    // 컴포넌트 언마운트 시 리스너 제거
    return () => {
      mediaQueryList.removeEventListener("change", updateDarkMode);
    };
  }, []);

  return { isDarkMode, toggleDark };
};

export default useStore;
```
