---
layout: post
title: "자잘한 도움말 #21 querySelector의 인자에 \"#1\"을 넣었더니 고장이 납니다."
subtitle: "블로그 목차(ToC)를 만드는 중 겪은 문제"
description: "CSS escape에 대하여"
date: 2024-11-04 18:00:00 +0900
category: micro

id: 21
slug: css-escape
tags: [💡, Front-end, CSS]

coverImage: "/assets/blog/coverImages/micro-21.png"

ogImage:
  url: "/assets/blog/coverImages/micro-21.png"
---

## TL;DR

- Web API `Document.querySelector()`: 인자로 전달된 CSS 선택자와 일치하는 현재 웹 페이지 내 엘리먼트 객체를 반환한다.
- 그런데 다음과 같은 선택자를 입력할 경우 오류가 발생한다.
```html
<h2 id="1. 블로그">1. 블로그</h2>
```
```javascript
document.querySelector("#1. 블로그");
// => 구문 오류! ['#1' is not a valid selector.]
```

<p class="center">
<img src="https://i.postimg.cc/J0gZL8qY/image.png" alt="error"/>
</p>

- Web API `CSS.escape()`를 사용해 문제를 해결할 수 있다.
```javascript
CSS.escape("1. 블로그");
// 문자열을 다음으로 변환: "\\31 \\.\\ 블로그"

document.querySelector(CSS.escape("1. 블로그"));
```
- `CSS.escape()`는 자동으로 문자열에 이스케이프 시퀀스(Escape Sequence)를 적용하는 유틸 함수다.

## 이하 그리 중요하진 않은 내용들

### 배경

지난번 글에 이어 이번 글도 블로그를 개편하면서 겪었던 문제를 주제로 한다. 요즘 달리 개인 프로젝트를 진행할 짬이 안 나는 시기를 보내는 중이기 때문에 이 블로그 개편 작업을 화수분으로 삼아 계속 글을 뽑아내야 할 듯. 아무튼 오늘 이야기해 볼 것은 `querySelector`와 CSS 선택자.

<p class="center">
<img src="https://i.postimg.cc/brbfjTQv/image.png" alt="toc" />
</p>

지금 글을 뷰포트 크기 768px 이상 환경에서 보고 있는 사람이라면 웹 페이지 우측에 화면 스크롤을 따라 떠다니는 글자 뭉치들을 확인할 수 있을 것이다. 현재 보고 있는 문단의 제목이 강조되어 있고, 마우스로 항목을 클릭하면 해당 문단으로 자동 스크롤을 해주는 유용한 컴포넌트. 바로 이 글의 <strong>목차</strong>다. 그런데 그게 떠다니는. 이걸 좀 더 유식한 척 영어로 표현하자면 "Floating <strong>Table of Contents(ToC)</strong>".

사실 이건 <a href="https://github.com/anteater333/Anteater_lab_v2">Jekyll 기반이었던 이전 버전의 블로그</a>에서도 있었던 기능이다. 다만 직접 구현은 아니었고, <a href="https://github.com/allejo/jekyll-toc">외부 패키지</a>를 <a href="https://github.com/anteater333/Anteater_lab_v2/blob/main/docs/_includes/toc.html">사용</a>했었다. 그리고 새 블로그의 프레임워크가 Next.js로 결정되며 이 패키지를 더이상 쓰기 어려워진 상황이 찾아오자 이참에 ToC 기능 정도는 직접 구현해봐야겠다 싶더라고.

### 현상

- 글에 따라서 목차의 구성이 변해야 한다.
- 사용자의 스크롤에 맞춰 움직이며 화면에 계속 노출되어야 한다.
- 목차를 클릭하면 해당 문단으로 이동해야 한다.
- 현재 읽고 있는 문단의 제목이 강조되어야 한다.

그래서 먼저 이야기해볼 것은 ToC를 만드는 과정. ToC는 위와 같은 기능을 구사해야 한다. 어떻게 했는지 하나씩 톺아보자.

<strong>1. 글에 따라서 목차의 구성이 변해야 한다.</strong>

똑똑한 우리의 컴포넌트는 지금 읽고 있는 글의 목차를 알아서 생성할 수 있어야 한다. 다시말해 ToC 컴포넌트는 현재 웹 페이지의 내용을 분석해 목차를 추출해야 한다. 근데 사실 이 웹 페이지의 원재료인 HTML이 특화된 능력이 바로 목차에 대해 기술하는 것이다. HyperText Markup Language, 문서의 구조를 설명하는 마크업 언어이기 때문이다. HTML에는 묶어서 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Heading_Elements">Heading</a> 이라고 부르는, `<h1>` ~ `<h6>` 태그가 존재한다. 6단계 까지 존재하는 이 태그는 문단의 제목을 나타내는 데에 사용된다. 즉, ToC 컴포넌트는 현재 작성글을 나타내는 HTML을 읽어 그 중 Heading 태그만 떼어내 그 목록을 생성하면 된다.

<p class="center rounded-edge-16">
  <img src="https://i.postimg.cc/3RRRFrqS/image.png" alt="toc-example"/>
</p>

이런 목차는 다음과 같은 HTML 문서를 읽어서 생성하는 것이다.

```html
<h2 id="tldr">TL;DR</h2>
<h2 id="이하-그리-중요하진-않은-내용들">이하 그리 중요하진 않은 내용들</h2>
<h3 id="node-version-manager">Node Version Manager</h3>
<h3 id="nvmrc"><code>.nvmrc</code></h3>
<h3 id="작업-디렉토리가-바뀔-때마다-자동으로-nodejs-버전-바꾸기">작업 디렉토리가 바뀔 때마다 자동으로 Node.js 버전 바꾸기</h3>
<h3 id="new-challenger">New Challenger</h3>
<h2 id="내가-배운-것">내가 배운 것</h2>
```

그리고 이 블로그엔 TypeScript와 React가 사용되었으므로 함수형 TSX 컴포넌트를 다음과 같이 설계할 수 있겠다. 위 HTML중 변경될 부분만 프로퍼티로 뽑아내자.

```tsx
type ToCItem = {
  /* 목차 내용 */
  text: string;
  /* 목차 ID */
  id: string;
  /* 목차 깊이 */
  level: number;
};

export function PostToC({ headings }: { headings: ToCItem[] }) {
  return (/* headings 데이터를 잘 조리해서 만든 레이아웃 */)
}
```

<strong>2. 사용자의 스크롤에 맞춰 움직이며 화면에 계속 노출되어야 한다.</strong>

사실 이 부분은 JavaScript(이 경우는 TypeScript겠지)가 개입할 영역은 아니다. 화면의 스크롤과 상관없이 항상 고정된 위치를 유지하게 만드는 CSS 속성을 사용하면 된다.

```css
.toc-container {
  position: sticky;
  top: 7.5rem;
}
```

`sticky` 속성으로 고정되는 위치의 기준점은 해당 엘리먼트가 포함된 부모 엘리먼트가 된다. 그래서 나는 다음과 같이 게시글 화면을 배치했다.

<p class="center rounded-edge-16">
<img src="https://i.postimg.cc/d3cd13Ff/image.png" alt="toc-design" />
</p>

`sticky` 속성이 부여된 곳은 ToC Container다. ToC Container는 게시글 영역의 높이와 동일한 높이를 가지게 되는 ToC Rail 안에 포함된다. 화면이 스크롤 되면 게시글 영역과 ToC Rail 영역이 스크롤 될 것이다. ToC Container는 레일 위에서 스크롤을 따라 위 아래로 이동하면서 사용자의 화면에 계속 노출된다.

<strong>3. 목차를 클릭하면 해당 문단으로 이동해야 한다.</strong>

(사진 하나만 넣자)

이것 역시 JavaScript가 개입할 영역은 아니다. URL에는 <strong>Anchor(앵커, 닻⚓)</strong>라는 것을 추가할 수 있다. 앵커는 이렇게 생겼다.

> <a href="https://blog.anteater-lab.link/micro/15/node-version-manager#new-challenger">https://blog.anteater-lab.link/micro/15/node-version-manager<strong>#new-challenger</strong></a>

여기서 <strong>해시(#)</strong>를 앵커, 그 뒤에 있는 "new-challenger" 부분을 <strong>프래그먼트(Fragment)</strong>라고 부른다. 이 URL을 누르면 해당 게시글로 이동할 뿐만 아니라 자동으로 "New Challenger"라는 제목을 가진 문단 까지 이동할 것이다. 앵커가 포함된 URL을 해석하는 브라우저의 표준적인 동작은 웹 페이지를 로드한 후 앵커로 지시한 프래그먼트에 해당하는 문서 내 위치로 이동하는 것이다. 만약 해당 URL이 현재 웹 페이지를 가리키고 있다면, 로드 과정 없이 바로 앵커가 지시하는 위치로 가게 될 것이다. 이 때 프래그먼트의 대상이 되는 HTML 엘레멘트의 속성(attribute)이 바로 `id` 이다. 즉 위 링크는 `<h3 id="new-challenger">New Challenger</h3>` 를 찾아 이동한 것이다. 이쯤 되면 ToC의 항목을 클릭했을 때 자동으로 해당 위치를 향해 스크롤이 되도록 만드는 기능에 대한 설명은 더 필요가 없겠지?

약간 여담을 해보자면, 흔히 HTML에서 링크를 만들 때 사용하는 `<a/>` 태그의 이름이 바로 앵커이다. 아마 원래 문서 내 이동을 수월히 하게 만드는 태그로 제안 되었을 건데 웹이 발전함에 따라 이젠 외부 링크로 이동할 때 사용하는 경우가 더 많아진게 아닐까 추측해본다. 항상 왜 링크를 만들 때 사용하는 태그가 `<a/>`인지 궁금했거든.

<strong>4. 현재 읽고 있는 문단의 제목이 강조되어야 한다.</strong>

다시 JavaScript가 힘을 쓸 차례가 왔다. 이 기능을 위해 ToC는 사용자의 스크롤과 현재 게시글의 위치에 반응해 동적으로 그 형태를 바꿔야 한다. 스크롤에 반응하는 것은 2번 항목과 같다고 느껴지지만, 이 경우는 스크롤이 특정 위치에 도달하는 것에 반응해야 한다는 점에서 차이가 있다. 이건 정적인 페이지만 가지곤 예측하기가 어려운 영역이거든.

```tsx
const observer = new IntersectionObserver(callback, options);
observer.observe(targetElement);
```

그래서 필요한 것이 바로 Web API `IntersectionObserver()`  
https://developer.mozilla.org/ko/docs/Web/API/IntersectionObserver


그그그 인터셉션 뭐시기. 아님말고.



근데 "### 1. 블로그" 이런 heading을 인식하지 못하는 문제 발생

### 원인

위 중 몇 번에서 오류가 났는가.

쿼리 셀렉터(querySelectorAll)에서 발생한 문제
쿼리 셀렉터에 대한 설명

### 해결

우선 이렇게 고쳐주면 된다
(수정 코드)

### 분석

CSS Escape란? -> 아주 간단한 문자열 변환 함수

그 외 CSS 인터페이스와 static methods
https://developer.mozilla.org/ko/docs/Web/API/CSS

## 내가 배운 것

- ToC 기능을 만드는 방법
- 쿼리 셀렉터
- Web API CSS 인터페이스
- CSS Escape

이 참에 <a href="https://developer.mozilla.org/ko/docs/Web/CSS/position">mdn 문서</a>를 살짝 훑어보다 알게 됐는데 `position: sticky;` 속성은 이전에 한 번 지나가듯 언급했던 <a href="https://developer.mozilla.org/ko/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context">쌓임 맥락</a>을 생성한다고 한다.

----

- CSS escape란?
    - #1 을 쿼리 셀렉터에 넣으면 고장난다.
    - https://stackoverflow.com/questions/20306204/using-queryselector-with-ids-that-are-numbers

- 
- CSS Web API에 대해 알아보자


----


## 요주의 코드

```jsx
type ToCItem = {
  text: string;
  id: string;
  level: number;
};

function PostToC({ headings }: { headings: ToCItem[] }) {
  const [current, setCurrent] = useState(-1);

  /* 현재 heading 강조 기능 */
  useEffect(() => {
    if (headings.length === 0) return;

    const headingEls = document.querySelectorAll(
      headings.map((h) => `#${CSS.escape(h.id)}`).join(", ")
    );

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setCurrent(headings.findIndex((h) => h.id === entry.target.id));
        }
      },
      {
        root: null,
        rootMargin: "0% 0% -66% 0%",
        threshold: 1,
      }
    );

    headingEls.forEach((el) => observer.observe(el));

    return () => observer.disconnect();
  }, [headings.length]);

  return (
    <PostToCNav className="toc-rail">
      <div className="toc-container">
        <ul className="toc-core">
          {headings.length > 0
            ? headings.map((heading, idx) => {
                return (
                  <li
                    key={`post-toc-item-${idx}`}
                    className={`${idx === current ? "current-heading" : ""}`}
                  >
                    {Array.from(Array(heading.level), (e, jdx) => {
                      return (
                        <p
                          className="toc-indent"
                          key={`toc-indent-${idx}-${jdx}`}
                        ></p>
                      );
                    })}
                    <a href={`#${heading.id}`}>{heading.text}</a>
                  </li>
                );
              })
            : undefined}
        </ul>
      </div>
    </PostToCNav>
  );
}
```